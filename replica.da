from nacl.public import PrivateKey, Box
import nacl.encoding
import nacl.hash
from nacl.bindings.utils import sodium_memcmp
import nacl.signing
config(clock is lamport)


olympus    = import_da('olympus')
client     = import_da('client')
messages   = import_da('messages')
operations = import_da('operations')
read_config_file = import_da('read_config_file')

def verify_msg(encrypted_msg, replica_box, msg_hash, verify_key_hex):
    verify_key = nacl.signing.VerifyKey(verify_key_hex, encoder=nacl.encoding.HexEncoder)

    recvd_msg = replica_box.decrypt(encrypted_msg)
    verified_msg = verify_key.verify(recvd_msg)

    HASHER = nacl.hash.sha256
    orig_hash = HASHER(recvd_msg, encoder=nacl.encoding.HexEncoder)
    ret = sodium_memcmp(orig_hash, msg_hash)
    return verified_msg.decode('ascii')

#Note: For phase 2 only one configuration is supported
def handle_failure_trigger(replica_id, client_id, sequence_number, failure_scenario_properties, failure_trigger,
config_id='config_0'):
    failure_error = None
    tuple = str(client_id) + ',' + str(sequence_number)
    if replica_id in failure_scenario_properties[config_id].keys():
        for tuples in failure_scenario_properties[config_id][replica_id]:
            if(tuple == tuples[0] and failure_trigger == tuples[1]):
                failure_error = tuples[2]
    return failure_error

def handle_failure_error(failure_error):
    failure_error_dict = {'operation':None, 'result':False, 'drop_result':False}
    if 'change_operation' in failure_error:
        failure_error_dict['operation'] = "get('x')"
    elif 'change_result' in failure_error:
        failure_error_dict['result'] = True
    elif 'drop_result_stmt' in failure_error:
        failure_error_dict['drop_result'] = True
    else:
        print("Unhandled failure error scenario")
    return failure_error_dict
    
class Replica(process):
    #setup replica
    #set the replica id, public and private keys
    def setup(olympus:olympus.Olympus, config:dict, public_key_map:dict, priv_key:PrivateKey,
    signing_key:cl.signing.SigningKey, verify_key_hex_map:dict, replica_id:int):
        output("Replica %s: public_key_map :%s verify_key_hex_map :%s"%(replica_id, public_key_map, verify_key_hex_map))
        self.dictionary = {}
        self.cache = {}
        self.failure_scenario_properties = {}

    #start the replica, it is in continuous wait state
    def run():
        output('Replica:', replica_id,'started')
        failure_scenario_properties = read_config_file.get_failure_scenario_properties() 
        await(False)

    """""""""""""""""""""""""""
        Methods for shuttles
    """""""""""""""""""""""""""
    #add operation at that slot
    def order_operation(operation, client):
        order_statement = messages.OrderStatement('order', operation)    # <'order', slot, operation>, slot is incremented in the class
        order_proof = messages.Proof(order_statement)
        forward_shuttle = messages.Shuttle(order_proof, 'head', config['replica_1'], client)
        return forward_shuttle

    #add order statement to order proof contained in the forward shuttle
    def add_order_statement(forward_shuttle, operation):
        order_statement = messages.OrderStatement('order', operation)
        order_proof = forward_shuttle.order_proof
        order_proof.add_statement(order_statement)

    #create result shuttle, done by the head replica
    def create_result_proof(result, operation):
        #TO-DO: calculate hash of result
        result_statement = messages.ResultStatement('result', result, 'hash', operation)
        result_proof = messages.Proof(result_statement)
        return result_proof

    #add result statement to result proof contained in the result shuttle
    def add_result_statement(shuttle, operation, result, hash):
        result_statement = messages.ResultStatement('result', result, 'hash', operation)
        result_proof = shuttle.result_proof
        result_proof.add_statement(result_statement)

    def cache_result(result_shuttle, result, client, sequence_number, client_id):
        cache[str(client_id) + '_' + str(sequence_number)] = (result_shuttle, result)


    """""""""""""""""""""""""""
        Receive Handlers
    """""""""""""""""""""""""""
    #Head Replica
    def receive(msg=('ClientRequest', operation, sequence_number, client_id,), from_=client):
        output("Replica Head: operation received from client :", operation)        

    # def receive(msg=('ClientRequest', encrypted_msg, msg_hash, verify_key_hex), from_=client):
    #     #output("Replica Head: msg received from client :", encrypted_msg)        
    #     replica_box = Box(priv_key, public_key_map['client'])
        
    #     operation = verify_msg(encrypted_msg, replica_box, msg_hash, verify_key_hex)
    #     output("Decrypted signed operation :", operation)
        
        #Check for failure trigger condition
        failure_error = handle_failure_trigger('replica_0', client_id, sequence_number, failure_scenario_properties,'client_request')
        output("failure_error :", failure_error)
        if failure_error:
            failure_error_dict = handle_failure_error(failure_error)

        if failure_error and failure_error_dict['operation']:
            operation = failure_error_dict['operation']
            output("Injecting failure change operation on head replica")

        #add operation at the next slot
        forward_shuttle = order_operation(operation, client)
        output('Replica:', replica_id, 'orderCommand transition')

        #apply operation to running state and add result proof to forward shuttle
        result = operations.perform_operation(operation, dictionary)
        output('State of dictionary at Head:', dictionary)
        result_proof = create_result_proof(result, operation)
        forward_shuttle.add_result_proof(result_proof)

        #send the forward shuttle, result shuttle to the next replica
        send(('ForwardRequest', forward_shuttle, operation, client, sequence_number, client_id,), to=config['replica_1'])


    def receive(msg=('ResultShuttle', forward_shuttle, result, sequence_number, client_id,), from_=replica):
        output('Replica Head:', replica_id, 'result shuttle received from previous replica :', forward_shuttle)
        my_index = int(replica_id.split('_')[1])

        #Check for failure trigger condition
        failure_error = handle_failure_trigger(replica_id, client_id, sequence_number, failure_scenario_properties, 'result_shuttle')
        output("failure_error :", failure_error)
        if failure_error:
            failure_error_dict = handle_failure_error(failure_error)

        #cache result and result shuttle
        cache_result(forward_shuttle, result, client, sequence_number, client_id)

        #send result shuttle to the previous replica
        send(('ResultShuttle', forward_shuttle, result, sequence_number, client_id,), to=config['replica_' + str(my_index - 1)])


    #Intermediate replicas
    def receive(msg=('ForwardRequest', forward_shuttle, operation, client, sequence_number, client_id,), from_=replica):
        output('Replica Intermediate:', replica_id, 'shuttle received from previous replica :', forward_shuttle)
        my_index = int(replica_id.split('_')[1])
        
        #Check for failure trigger condition
        failure_error = handle_failure_trigger(replica_id, client_id, sequence_number, failure_scenario_properties,'forwarded_request')
        output("failure_error :", failure_error)
        if failure_error:
            failure_error_dict = handle_failure_error(failure_error)

        #TO-DO: check validity of order proof in the shuttle
        #we are updating the sender on the shuttle because we want to verify it

        #add order statement to the order proof in the shuttle
        add_order_statement(forward_shuttle, operation)
        output('Replica:', replica_id, 'orderCommand transition')
        forward_shuttle.update_sender(config['replica_' + str(my_index)])

        #applying operation to running state and add result statement to the result shuttle
        result = operations.perform_operation(operation, dictionary)
        output('State of dictionary at', 'replica_' + str(my_index),':', dictionary)
        add_result_statement(forward_shuttle, operation, result, 'hash')

        #send both shuttles to next replica
        if  my_index == len(config) - 3:
            send(('TailRequest', forward_shuttle, operation, client, sequence_number, client_id,), to=config['tail'])
        else:
            send(('ForwardRequest', forward_shuttle, operation, client, sequence_number, client_id,), to=config['replica_' + str(my_index + 1)])


    def receive(msg=('ResultShuttle', forward_shuttle, result, client, sequence_number, client_id,), from_=replica):
        output('Replica Intermediate:', replica_id, 'result shuttle received from previous replica :', forward_shuttle)
        my_index = int(replica_id.split('_')[1])
        
        #cache result and result shuttle
        cache_result(forward_shuttle, result, client, sequence_number, client_id)

        #send result shuttle to the previous replica
        send(('ResultShuttle', forward_shuttle, result), to=config['replica_' + str(my_index - 1)])


    #Tail Replica
    def receive(msg=('TailRequest', forward_shuttle, operation, client, sequence_number, client_id,), from_=replica):
        output('Replica Tail: shuttle received in tail replica :', forward_shuttle)

        #Check for failure trigger condition
        replica_id = 'replica_' + str(len(config) - 1)
        failure_error = handle_failure_trigger(replica_id, client_id, sequence_number, failure_scenario_properties,'forwarded_request')
        output("failure_error :", failure_error)
        if failure_error:
            failure_error_dict = handle_failure_error(failure_error)
 

        #add order statement to the order proof in the shuttle
        add_order_statement(forward_shuttle, operation)
        output('Replica:', replica_id, 'orderCommand transition')
        output('Replica:', replica_id, 'added order statement to shuttle.(', forward_shuttle.slot_number, ', ', operation, ') is persistent')

        #applying operation to running state and add result statement to the result shuttle
        result = operations.perform_operation(operation, dictionary)
        output('State of dictionary at Tail:', dictionary)
        add_result_statement(forward_shuttle, operation, result, 'hash')

        #the order proof is complete, send result to client
        send(('Result', forward_shuttle.result_proof, result,), to=client)
        output("Tail Replica: sent reply to client", client)

        #cache result and result shuttle
        cache_result(forward_shuttle, result, client, sequence_number, client_id)

        #send the shuttle in the reverse direction
        send(('ResultShuttle', forward_shuttle, result, client, sequence_number,  client_id,), to=config['replica_' + str(len(config) - 2)])

def main():
    output("In replica main")
