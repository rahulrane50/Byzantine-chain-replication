from nacl.public import PrivateKey, Box
import nacl.encoding
import nacl.hash
import nacl.signing
import pickle
import time
from nacl.bindings.utils import sodium_memcmp

config(clock is lamport)


olympus    = import_da('olympus')
client     = import_da('client')
messages   = import_da('messages')
operations = import_da('operations')
sign = import_da('sign')
read_config_file = import_da('read_config_file')


#Note: For phase 2 only one configuration is supported
def handle_failure_trigger(replica_id, client_id, sequence_number, failure_scenario_properties, failure_trigger,
config_id='config_0'):
    failure_error = None
    tuple = str(client_id) + ',' + str(sequence_number)
    if replica_id in failure_scenario_properties[config_id].keys():
        for tuples in failure_scenario_properties[config_id][replica_id]:
            if(tuple == tuples[0] and failure_trigger == tuples[1]):
                failure_error = tuples[2]
    return failure_error


def handle_failure_error(failure_error):
    failure_error_dict = {'operation':None, 'result':False, 'drop_result':False}
    if 'change_operation' in failure_error:
        failure_error_dict['operation'] = "get('x')"
    elif 'change_result' in failure_error:
        failure_error_dict['result'] = True
    elif 'drop_result_stmt' in failure_error:
        failure_error_dict['drop_result'] = True
    else:
        print("Unhandled failure error scenario")
    return failure_error_dict

def dump_expected_result(dictionary, client_id):
    fname = "testcase_" + str(client_id) + "_result.txt"
    testing_file = open(fname, "wb")
    pickle.dump(dictionary, testing_file, pickle.HIGHEST_PROTOCOL)
    testing_file.close()

def verify_result_statement(verify_key, statement, hashed_result):
    verified = True
    result_statement = None
    verified_result_statement = sign.verify_sign(verify_key, statement)
    #print("verified_result_statement :", verified_result_statement)
    if verified_result_statement == None:
        verified = False
        return verified
    if verified:
        result_statement = pickle.loads(verified_result_statement)
    if not sodium_memcmp(hashed_result, result_statement.result_hash):
        output('Client ', id, ': The hash of result did not match')
        verified = False
    return verified

class Replica(process):
    #setup replica
    #set the replica id, public and private keys

    def setup(olympus:olympus.Olympus, config:dict, public_key_map:dict, priv_key:PrivateKey,
    signing_key:cl.signing.SigningKey, verify_key_hex_map:dict, replica_id:int, mode:str):
        #output("Replica %s: public_key_map :%s verify_key_hex_map :%s"%(replica_id, public_key_map, verify_key_hex_map))
        self.dictionary = {}
        self.cache = {}
        self.failure_scenario_properties = {}
        self.slot_number = 0
        self.history = []

    #start the replica, it is in continuous wait state
    def run():
        output('Replica:', replica_id,'started in', mode, 'mode')
        failure_scenario_properties = read_config_file.get_failure_scenario_properties() 
        await(False)
        output("out of await")

    """""""""""""""""""""""""""
        Methods for shuttles
    """""""""""""""""""""""""""
    #replica head: add operation at that slot
    def order_operation(operation, client):
        forward_shuttle = None
        slot_number = slot_number + 1
        verified = check_history(history, slot_number, operation, replica_id)
        #verified = check_previous_order_proofs(slot_number, operation)
        if not verified:
            output('Replica Head: detected invalid slot and operation in previous order proofs. Aborting..')
            #TO-DO: make the system move forward still
        else:
            output('Replica', replica_id, ': successfully verified previous order statements')
            order_statement = messages.OrderStatement('order', slot_number, operation)    # <'order', slot, operation>, slot is incremented in the class
            signed_order_statement = sign.sign_msg(signing_key, pickle.dumps(order_statement))
            
            order_proof = messages.Proof(signed_order_statement, slot_number, operation)

            forward_shuttle = messages.Shuttle(order_proof, 'head', config['replica_1'], client)
            history.append(order_proof)
            output('Replica Head: Added operation', operation, 'at slot', slot_number)
        return forward_shuttle


    def check_history(history, slot_number, operation, replica_index):
        verified = True
        for order_proof in history:
            if order_proof.slot == slot_number or order_proof.slot > slot_number:
                verified = False
                output('Replica', replica_id, 'detected invalid slot and operation')
                break
            else:
                verify_signed_order_statements(order_proof, replica_index, slot_number, operation)
        return verified

    #check slots used by older order proofs
    def check_previous_order_proofs(slot_number, operation):
        verified = True
        output('############### in check previous order proofs', history)
        for order_proof in history:
            output('############### in for loop check previous order proofs :', order_proof.slot)
            # slot_number: new slot number, operation: new incoming operation
            # for each order proof in the history of head
            # order proof will have previous slot and operation
            # if any previous slot equals the new slot, the new slot is wrong
            # all previous slots must be smaller than the current slot
            # the operation at that slot can be same or different
            # checking for same operation at same slot will only happen during execution of a new operation
            # this checking will not be considered from the history
            if order_proof.slot == slot_number or order_proof.slot > slot_number:
                verified = False
                output('Replica', replica_id, 'detected invalid slot and operation')
                break
            else:
                # check only the slot used by order statement said by tail in every order proof
                # since, invalid slots used by any other replica would have been previously detected
                # TO-DO: or a previous replica could have been faulty, and do this checking for all order statements
                # but what if the head is also faulty? For now, do this
                order_statements = order_proof.statements
                output("order statements :", order_statements)
                result = sign.verify_sign(verify_key_hex_map['tail'], order_statements[-1])
                output("result :", result)
                result = pickle.loads(result)
                if result.slot > slot_number or result.slot == slot_number:
                    output('Replica', replica_id, 'detected invalid slot and operation')
                    verified = False
                    break
                output("############### verified")
        return verified


    def check_previous_statements(unsigned_order_statements, slot, operation):
        verified = True
        for statement in unsigned_order_statements:            
            if not (statement.slot == slot and statement.operation == operation):
                output('Replica', replica_id, 'detected invalid slot and operation')
                verified = False
                break
        output('returning from check_prev #####')
        return verified


    #add order statement to order proof contained in the forward shuttle
    def add_order_statement(forward_shuttle, operation, replica_index):
        #TO-DO: add verification of all signed statements in the order proof
        #if that passes, do this
        slot_number += 1
        result = verify_signed_order_statements(forward_shuttle.order_proof, replica_index, slot_number, operation)
        output('Replica', replica_id, ': successfully verified previous order statements')
        if result == 'OK':
            order_statement = messages.OrderStatement('order', slot_number, operation)
            signed_order_statement = sign.sign_msg(signing_key, pickle.dumps(order_statement))

            order_proof = forward_shuttle.order_proof            
            order_proof.add_statement(signed_order_statement)
            history.append(order_proof)
        elif result == 'fail':
            #TO-DO: drop this message, and make the system move forward
            output('Invalid order proof detected at replica', replica_id)


    def verify_signed_order_statements(order_proof, replica_index, slot_number, operation):
        order_statements = order_proof.statements
        index = 0
        unsigned_order_statements = []        
        result = sign.verify_sign(verify_key_hex_map['head'], order_statements[index])
        verified = True

        if result == None:
            return 'fail'
        else:
            result = pickle.loads(result)            
            unsigned_order_statements.append(result)

        if not replica_index == 'head' and not replica_index == 'tail':
            map_key = 'replica_'
            for index in range(1, replica_index):
                result = sign.verify_sign(verify_key_hex_map[map_key + str(index)], order_statements[index])

                if result == None:
                    return 'fail'
                else:
                    result = pickle.loads(result)
                    unsigned_order_statements.append(result)
        elif replica_index == 'tail':
            result = sign.verify_sign(verify_key_hex_map['tail'], order_statements[-1])
            if result == None:
                return 'fail'
            else:
                result = pickle.loads(result)
                unsigned_order_statements.append(result)
        
        verified = check_previous_statements(unsigned_order_statements, slot_number, operation)

        #this check is for actual order statements
        if not verified:
            return 'fail'
        return 'OK'

    def verify_result_proof(result_proof, result):
        #verify hash
        hashed_result = sign.generate_hash(result.encode('ascii'))
        result_statements = result_proof.statements
        verified = True
        output("verifying order proof for replica :", replica_id)
        verified = verify_result_statement(verify_key_hex_map['head'], result_statements[0], hashed_result)
        if not verified:
            return False

        index = 1
        for statement in result_statements[1:-1]:
            verified = verify_result_statement(verify_key_hex_map['replica_'+str(index)], statement, hashed_result)
            if not verified:
                break
            index += 1
        verified = verify_result_statement(verify_key_hex_map['tail'], result_statements[-1], hashed_result)
        return verified

    #create result shuttle, done by the head replica
    def create_result_proof(result, slot, operation):
        output('################inside create result proof')
        hashed_result = sign.generate_hash(result.encode('ascii'))
        result_statement = messages.ResultStatement('result', result, hashed_result, operation)
        output('inside create result proof', result_statement, hashed_result)
        #TO-DO: sign result statement before adding to proof

        signed_result_statement = sign.sign_msg(signing_key, pickle.dumps(result_statement))
        result_proof = messages.Proof(signed_result_statement, slot, operation)
        return result_proof


    #add result statement to result proof contained in the result shuttle
    def add_result_statement(shuttle, operation, result, hashed_result):
        #TO-DO: sign result statement before adding to proof
        result_statement = messages.ResultStatement('result', result, hashed_result, operation)
        signed_result_statement = sign.sign_msg(signing_key, pickle.dumps(result_statement))
        result_proof = shuttle.result_proof
        result_proof.add_statement(signed_result_statement)


    #cache result and result shuttle at each replica
    def cache_result(result_shuttle, result, client, sequence_number, client_id):
        cache[str(client_id) + '_' + str(sequence_number)] = (result_shuttle, result)


    """""""""""""""""""""""""""
        Receive Handlers
    """""""""""""""""""""""""""
    #Head Replica
    def receive(msg=('ClientRequest', encrypted_operation, operation_hex, sequence_number, client_id,), from_=client):
        replica_box = Box(priv_key, public_key_map['client'])

        #TO-DO: handle that verification will fail
        #verify that the operation really came from that particular client
        operation = sign.verify_msg(encrypted_operation, replica_box, operation_hex,
        verify_key_hex_map['client_'+str(client_id)])
        output("Replica Head: operation received from client :", operation)

        #Check for failure trigger condition
        failure_error = handle_failure_trigger('replica_0', client_id, sequence_number, failure_scenario_properties,'client_request')
        output("failure_error :", failure_error)
        if failure_error:
            failure_error_dict = handle_failure_error(failure_error)

        if failure_error and failure_error_dict['operation']:
            operation = failure_error_dict['operation']
            output("Injecting failure change operation on head replica")
        
        #add operation at the next slot
        forward_shuttle = order_operation(operation, client)
        output('Replica:', replica_id, 'orderCommand transition')

        #apply operation to running state and add result proof to forward shuttle
        result = operations.perform_operation(operation, dictionary)
        output('State of dictionary at Head:', dictionary)
        output('Result obtained at Head for operation:', operation,'is: ',result)
        result_proof = create_result_proof(result, slot_number, operation)
        output('forward shuttle ####', forward_shuttle)
        forward_shuttle.add_result_proof(result_proof)

        output('Replica Head: Sequence number', sequence_number)
        
        time.sleep(10)

        #send the forward shuttle, result shuttle to the next replica
        send(('ForwardRequest', forward_shuttle, operation, client, sequence_number, client_id,), to=config['replica_1'])


    def receive(msg=('ResultShuttle', result_shuttle, result, sequence_number, client_id,), from_=replica):
        output('Replica :', replica_id, 'result shuttle received from previous replica :', result_shuttle)
        if replica_id != 'head':
            my_index = int(replica_id.split('_')[1])

        #Check for failure trigger condition
        failure_error = handle_failure_trigger(replica_id, client_id, sequence_number, failure_scenario_properties, 'result_shuttle')
        output("failure_error :", failure_error)
        if failure_error:
            failure_error_dict = handle_failure_error(failure_error)
            if failure_error_dict['result']:
                output("Injecting result shuttle failure.")
                result = "OK"
            elif failure_error_dict['drop_result']:
                output("Injecting drop head result statement failure.")
                result_shuttle.result_proof.statements.pop(0)
        
        #Validate order proof with previous
        verified = verify_result_proof(result_shuttle.result_proof, result)
        if not verified:
            output("Result proof received is invalid")
            #retransmit_request()
        else:
            output("Result proof is validated successfully.")

        #cache result and result shuttle
        cache_result(result_shuttle, result, client, sequence_number, client_id)

        #send result shuttle to the previous replica
        if replica_id == 'head':
            return
        elif (replica_id == 'replica_1'):
            send(('ResultShuttle', result_shuttle, result, sequence_number, client_id,), to=config['head'])
        else:
            send(('ResultShuttle', result_shuttle, result, sequence_number, client_id,), to=config['replica_' + str(my_index - 1)])


    #Intermediate replicas
    def receive(msg=('ForwardRequest', forward_shuttle, operation, client, sequence_number, client_id,), from_=replica):
        output('Replica Intermediate:', replica_id, 'shuttle received from previous replica :', forward_shuttle)
        my_index = int(replica_id.split('_')[1])

        #Check for failure trigger condition
        failure_error = handle_failure_trigger(replica_id, client_id, sequence_number, failure_scenario_properties,'forwarded_request')
        output("failure_error :", failure_error)
        if failure_error:
            failure_error_dict = handle_failure_error(failure_error)        

        #TO-DO: check validity of order proof in the shuttle ## done, verifying from within add_order_statement
        #we are updating the sender on the shuttle because we want to verify it
        #add order statement to the order proof in the shuttle
        add_order_statement(forward_shuttle, operation, my_index)
        output('Replica:', replica_id, 'orderCommand transition')
        forward_shuttle.update_sender(config['replica_' + str(my_index)])

        #applying operation to running state and add result statement to the result shuttle
        result = operations.perform_operation(operation, dictionary)
        output('State of dictionary at', 'replica_' + str(my_index),':', dictionary)
        add_result_statement(forward_shuttle, operation, result, sign.generate_hash(result.encode('ascii')))

        #send both shuttles to next replica
        if  my_index == len(config) - 3:
            send(('TailRequest', forward_shuttle, operation, client, sequence_number, client_id,), to=config['tail'])
        else:                                                                                                                                                           
            send(('ForwardRequest', forward_shuttle, operation, client, sequence_number, client_id,), to=config['replica_' + str(my_index + 1)])

    #Tail Replica
    def receive(msg=('TailRequest', forward_shuttle, operation, client, sequence_number, client_id,), from_=replica):
        output('Replica Tail: shuttle received in tail replica :', forward_shuttle)

        #Check for failure trigger condition
        tmp_replica_id = 'replica_' + str(len(config) - 1)
        failure_error = handle_failure_trigger(tmp_replica_id, client_id, sequence_number, failure_scenario_properties,'forwarded_request')
        output("failure_error :", failure_error)
        if failure_error:
            failure_error_dict = handle_failure_error(failure_error)
 

        # add order statement to the order proof in the shuttle
        # 3rd arg here is len(configuration) instead of 'tail', b/c we loop
        # on that arg in the called method
        add_order_statement(forward_shuttle, operation, len(config) - 2)
        output('Replica:', replica_id, 'orderCommand transition')
        output('Replica:', replica_id, 'added order statement to shuttle.(', slot_number, ', ', operation, ') is persistent')

        #applying operation to running state and add result statement to the result shuttle
        result = operations.perform_operation(operation, dictionary)
        output('State of dictionary at Tail:', dictionary)
        add_result_statement(forward_shuttle, operation, result, sign.generate_hash(result.encode('ascii')))

        #the order proof is complete, send result to client
        send(('Result', forward_shuttle.result_proof, result,str(client_id) + str(sequence_number), operation), to=client)
        output("Tail Replica: sent reply to client", client)
        dump_expected_result(dictionary, client_id)

        #cache result and result shuttle
        cache_result(forward_shuttle, result, client, sequence_number, client_id)

        #send the shuttle in the reverse direction
        send(('ResultShuttle', forward_shuttle, result, sequence_number, client_id,), to=config['replica_' +
        str(len(config) - 2)])
        output("Sent result shuttle")


def main():
    output("In replica main")
