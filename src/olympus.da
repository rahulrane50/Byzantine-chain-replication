import sys
import nacl.utils
import pickle
import time
from nacl.public import PrivateKey, Box
import nacl.hash
import nacl.encoding
import nacl.signing
from nacl.bindings.utils import sodium_memcmp
import itertools

# config(channel is fifo, clk is lamport)
config(channel = 'fifo')
config(clock = 'lamport')

replica = import_da('replica')
client  = import_da('client')
sign = import_da('sign')
config_file = import_da('read_config_file')

def generate_pub_priv_keys():
    priv_key = PrivateKey.generate()
    pub_key = priv_key.public_key
    return (priv_key, pub_key)

def generate_sign_key():
    signing_key = nacl.signing.SigningKey.generate()
    verify_key = signing_key.verify_key
    verify_key_hex = verify_key.encode(encoder=nacl.encoding.HexEncoder)
    return signing_key, verify_key_hex

class Olympus(process):
    def setup(no_of_configuration:int, no_of_replicas:int, num_of_clients:int, 
        set_of_replicas:set, head_timeout:int, nonhead_timeout:int, checkpt_interval: int):
        self.configuration = {}
        for id in range(0, no_of_configuration):
            self.configuration['config_' + str(id)] = {}
        self.public_key_map = {}
        self.priv_key_map = {}
        self.signing_key_map = {}
        self.verify_key_hex_map = {}
        self.current_configuration = 0
        self.reconfiguring = False
        self.wedged_statements = []
        self.caughtup_statements = []
        self.verified_running_state = False
        self.send_config_client = False

    def create_keys(reconfig):
        public_old_keys = sign.generate_hash(pickle.dumps(public_key_map))
        private_old_keys = sign.generate_hash(pickle.dumps(priv_key_map))

        output('Olympus creating new keys', reconfig)
        priv_key, pub_key = generate_pub_priv_keys()
        public_key_map['head'] = pub_key
        priv_key_map['head'] = priv_key
 
        priv_key, pub_key = generate_pub_priv_keys()
        public_key_map['tail'] = pub_key
        priv_key_map['tail'] = priv_key
 
        for index in range(1, len(configuration['config_' + str(current_configuration)]) - 1):
            priv_key, pub_key = generate_pub_priv_keys()
            public_key_map['replica_' + str(index)] = pub_key
            priv_key_map['replica_' + str(index)] = priv_key
 
        public_new_keys = sign.generate_hash(pickle.dumps(public_key_map))
        private_new_keys = sign.generate_hash(pickle.dumps(priv_key_map))

        output('private keys ', sodium_memcmp(private_old_keys, private_new_keys))
        output('public keys ', sodium_memcmp(public_old_keys, public_new_keys))

        if not reconfig:
            output('Olympus creating new keys', reconfig)
            priv_key, pub_key = generate_pub_priv_keys()
            public_key_map['olympus'] = pub_key
            priv_key_map['olympus'] = priv_key

            for index in range(0, num_of_clients):
                priv_key, pub_key = generate_pub_priv_keys()
                public_key_map['client_' + str(index)] = pub_key
                priv_key_map['client_' + str(index)] = priv_key        
        

    def create_signing_keys(reconfig):
        output('Olympus creating new signing keys', reconfig)
        signing_key_map['head'], verify_key_hex_map['head'] = generate_sign_key()
        signing_key_map['tail'], verify_key_hex_map['tail'] = generate_sign_key()
        for index in range(1, len(configuration['config_' + str(current_configuration)]) - 1):
            sign_key, verify_key_hex = generate_sign_key()
            signing_key_map['replica_' + str(index)] = sign_key
            verify_key_hex_map['replica_' + str(index)] = verify_key_hex

        if not reconfig:
            output('Olympus creating new signing keys', reconfig)
            signing_key_map['olympus'], verify_key_hex_map['olympus'] = generate_sign_key()

            for index in range(0, num_of_clients):
                signing_key_map['client_' + str(index)], verify_key_hex_map['client_' + str(index)] = generate_sign_key()


    def verify_order_proof(replica_history, longest_hist_slot, longest_hist_op, replica_id):
        # why loop here?
        for order_proof in replica_history:
            if order_proof.slot == longest_hist_slot:
                if order_proof.operation != longest_hist_op:
                    output("Invalid operation detected at slot ", order_proof.slot, " for replica ",replica_id)
                    return False
        return True


    def verify_history(histories, set_of_quorums):
        longest_running_history = []
        verified = True
        longest_running_hist_replica = -1
        valid_quorum = None
        cnt = 0
        temp = None
        t = (no_of_replicas - 1)/2

        while(cnt < t + 1):
            for replica_id, history in histories:
                if len(history) > len(longest_running_history) and not replica_id == temp:
                    longest_running_history = history
                    longest_running_hist_replica = replica_id

            quorum_with_replica = []
            for q in set_of_quorums:
                if longest_running_hist_replica in q:
                    quorum_with_replica.append(q)

            output("Olympus: Found longest running history for replica ", longest_running_hist_replica," as : ", longest_running_history)

            for quorum in quorum_with_replica:
                for replica_id, history in histories:
                    # if cnt >= t + 1:
                    #     break
                    if replica_id in quorum:
                        error = False
                        for order_proof in longest_running_history:
                            verified = verify_order_proof(history, order_proof.slot, order_proof.operation, replica_id)
                            if not verified:
                                error = True
                                break

                        if not error:
                            cnt += 1
                            output("History of replica ", replica_id, " is consistent with longest running history.")

                if cnt >= t + 1:
                    output("Quorum of replicas has consistent valid histories.")
                    break
                else:
                    #TODO: need to select another quorum
                    output("Selecting a different quorum")
                    cnt = 0
                    # verified = False
            if cnt < t + 1:
                temp = longest_running_hist_replica
            else:
                break

        return verified, longest_running_history


    def check_caughtup_statements(caughtup_statements):
        replica_running_hash = caughtup_statements[0][1]
        for replica_id, running_hash in caughtup_statements:
            if running_hash != replica_running_hash:
                output("Replica id :", replica_id, " running state hash value did not match with other replicas running state hash.")
                return False
        return True


    def run():
        """Create configuration of replicas, and start them"""
        configuration['config_' + str(current_configuration)] = create_replica_config(list(set_of_replicas))
        
        """Create public and private keys for replicas and client."""
        self.create_keys(False)
      
        self.create_signing_keys(False)

        setup_and_start_replicas(configuration['config_' + str(current_configuration)], public_key_map, priv_key_map, signing_key_map,
        verify_key_hex_map, head_timeout, nonhead_timeout, checkpt_interval)

        #Olympus always stays on
        await(False)

   
    def receive(msg=('GetConfiguration', client_id), from_=client):
        output('Olympus: client requested configuration. reconfiguring', reconfiguring)
        if not reconfiguring:
            output('Olympus: Sending configuration to client:', client_id)
            send(('Configuration', configuration['config_' + str(current_configuration)], current_configuration,), to=client)
        elif reconfiguring:
            send_config_client = (True, client)


    def receive(msg=('GetKeys', client_id), from_=client):
        output('Sending keys to client:', client_id)
        send(('Keys', public_key_map, priv_key_map['client_'+ str(client_id)]), to=client)


    def receive(msg=('GetSigningKeys', client_id), from_=client):
        output('Sending signing keys to client:', client_id)
        send(('SigningKeys', signing_key_map['client_' + str(client_id)], verify_key_hex_map), to=client)


    def receive(msg=('ForwardRequest', operation,), from_=replica):
        #Broadcast msg to all replicas
        anymsg = "This is Olympus!!"
        output("handling forward request msg from replica :", operation)
        if(replica == configuration['config_' + str(current_configuration)]['head']):
            send(('OlympusRequest', anymsg), to=replica)


    def receive(msg=('ReconfigurationRequest', reason, operation, sequence_number, client_id, replica_id, ), from_=replica):
        output("Olympus: Received reconfiguration request from", replica_id, "for ", reason,"in operation ", operation)
        longest_running_history = None

        if not reconfiguring:
            reconfiguring = True
            config = configuration['config_' + str(current_configuration)]
            send_wegde_requests(config)

            output("RR: config :", config, len(config))
            await(len(listof(replica, received(('WedgedStatement', signed_wedged_statement, replica_id,), from_=replica))) == len(config))
            # while(len(wedged_statements) < len(config)):
                # await(len(listof(replica, received(('WedgedStatement', signed_wedged_statement, replica_id,), from_=replica))) <= len(config))
                #await(len(listof(replica, received(('WedgedStatement', wedged_statement,), from_=replica))) == len(config))
                #await(len(listof(wedge_statements, received(('WedgedStatement', wedged_statement,), from_=replica))) == len(config))
            output("Olympus: Received wedge statements from all replicas.")
            longest_running_history = check_wedged_statements(wedged_statements)

            for replica_id, statement in wedged_statements:
                verified_statement = sign.verify_sign(verify_key_hex_map[replica_id], statement)
                verified_statement = pickle.loads(verified_statement)
                catchup_statement = longest_running_history[len(verified_statement.history):]
                #send catchup statement
                output("Olympus : Sending catchup statement to replica ", replica_id)
                send(('CatchupStatement', catchup_statement), to=config[replica_id])
           
            verified = False
            await(len(listof(replica, received(('CaughtupStatement', hashed_running_state, replica_id,), from_=replica))) == len(config))
            output("Olympus :Received all caughtup statements")
            verified = check_caughtup_statements(caughtup_statements) 
            if verified:
                output("All replicas caught up messages matched successfully.")
            else:
                #TODO: Need to choose different quorum
                pass

            output("Olympus :Sending getrunning history request.")
            send('GetRunningState', to=config['head'])
            if not verified_running_state:
                for index in range(1, len(config) - 1):
                    if not verified_running_state:
                        send('GetRunningState', to=config['replica_' + str(index)])
                if not verified_running_state:
                    send('GetRunningState', to=config['tail'])  

            output("Olympus: Creating init hist statement.")
            #init_hist_statement = create_hist_statement(hashed_running_state)
            #send init_hist_statement to new configuration
            await(verified_running_state)
            #killing exisiting replicas
            output("Sending terminate message to each replica")
            send('Terminate', to=configuration['config_' + str(current_configuration)]['head'])
            for index in range(1, len(config) - 1):
                send('Terminate', to=configuration['config_' + str(current_configuration)]['replica_' + str(index)])
            send(('Terminate'), to=configuration['config_' + str(current_configuration)]['tail'])

            create_new_replicas()

            send('Hello', to=configuration['config_' + str(current_configuration)]['head'])
            for index in range(1, len(config) - 1):
                send('Hello', to=configuration['config_' + str(current_configuration)]['replica_' + str(index)])
            send(('Hello'), to=configuration['config_' + str(current_configuration)]['tail'])

            await(len(listof(replica, received(('ReplicaUp', replica_id), from_=replica))) == len(configuration['config_' + str(current_configuration)]))            
            if send_config_client[0]:
                output('current_configuration ', current_configuration)
                output('Olympus: Sending configuration to client', client_id)
                send(('Configuration', configuration['config_' + str(current_configuration)], current_configuration,), to=send_config_client[1])


    def receive(msg=('ReplicaUp', replica_id), from_=replica):
        output("Olympus received up message from replica ", replica_id)


    def create_new_replicas():
        current_configuration += 1
        configuration['config_' + str(current_configuration)] = {}

        replicas = new(replica.Replica, num=no_of_replicas, at='ReplicasNode')
        configuration['config_' + str(current_configuration)] = create_replica_config(list(replicas))
        output('Olympus creating new configuration. New config number ', current_configuration)
        """Create public and private keys for replicas"""
        self.create_keys(True)
        self.create_signing_keys(True)
        setup_and_start_replicas(configuration['config_' + str(current_configuration)], public_key_map, priv_key_map, signing_key_map,
        verify_key_hex_map, head_timeout, nonhead_timeout, checkpt_interval)


    def send_wegde_requests(config):
        output("Sending wedge requests each replica")
        send('WedgeRequest', to=config['head'])
        for index in range(1, len(config) - 1):
            send('WedgeRequest', to=config['replica_' + str(index)])
        send('WedgeRequest', to=config['tail'])

        
    def receive(msg=('WedgedStatement', wedged_statement, replica_id,), from_=replica):
        output("Olympus received wedge statement from replica ", replica_id)
        wedged_statements.append((replica_id, wedged_statement))

    
    def receive(msg=('CaughtupStatement', hashed_running_state, replica_id,), from_=replica):
        caughtup_statements.append((replica_id, hashed_running_state))


    def receive(msg=('RunningState', running_state,replica_id,), from_=replica):
        output("Olympus : Received running state from replica ", replica_id)
        hashed_running_state = sign.generate_hash(pickle.dumps(running_state))
        if hashed_running_state == caughtup_statements[0][1] and not verified_running_state:
            verified_running_state = True
            output("Hash value of running state received matched with caughtup messages hashed running state value.")

 
    def check_wedged_statements(wedged_statements):
        count = no_of_replicas
        t = int((no_of_replicas - 1)/2)
        error = False
        valid_signatures = []
        histories = []
        checkpoint_proofs = []
        running_states = []
        set_of_quorums = []

        replicas = list(configuration['config_' + str(current_configuration)].keys())
        set_of_quorums = list(itertools.combinations(replicas, t+1))
        output('quorums', set_of_quorums)

        for element in wedged_statements:
            if count < t + 1:
                output('Olympus: Could not obtain a quorum of t+1 replicas')
                error = True
                break

            replica_id = element[0]
            statement  = element[1]
            #verify signature
            verified_statement = sign.verify_sign(verify_key_hex_map[replica_id], statement)
            if verified_statement:
                verified_statement = pickle.loads(verified_statement)
                histories.append((replica_id, verified_statement.history))
                checkpoint_proofs.append((replica_id, verified_statement.checkpoint_proof))
                running_states.append((replica_id, verified_statement.running_state))
                valid_signatures.append(replica_id)
            else:
                count -= 1

        verified = False
        if not error:
            output("Olympus sign verified for all wedge statements.")
            verified, longest_running_history = verify_history(histories, set_of_quorums)
            # get history with maximum length from list
            # for all histories, check that the slot and operation upto the common prefix are equal
            # find t+1 equal histories and choose as quorum
            # if t+1 is not found, choose different quorum
            # find difference of longest history and each replica's history
            # send sequence of operations to all replicas
            # each replica will execute the sent operations on its dictionary
            # calculate hash of dictionary at each replica and send to olympus
            # olympus collect all hashes, and check that all are equal
            # if any is unequal, choose new quorum from received hashes
            # don't repeat steps from above because we already have all values corresponding to all replicas

        if verified:
            return longest_running_history
        
        return None


    def create_replica_config(list_of_replicas):
        configuration['config_' + str(current_configuration)]['head'] = list_of_replicas[0]
        configuration['config_' + str(current_configuration)]['tail'] = list_of_replicas[-1]

        index = 1
        for replica_itr in list_of_replicas[1:-1]:
            configuration['config_' + str(current_configuration)]['replica_' + str(index)] = replica_itr
            index += 1
        return configuration['config_' + str(current_configuration)]


    def setup_and_start_replicas(configuration, public_key_map, priv_key_map, signing_key_map, verify_key_hex_map, head_timeout, nonhead_timeout, checkpt_interval):
        #setup and start head and tail
        setup(configuration['head'], (self, configuration, public_key_map, priv_key_map['head'],
        signing_key_map['head'], verify_key_hex_map, 'head', 'ACTIVE', head_timeout, nonhead_timeout, checkpt_interval))
        setup(configuration['tail'], (self, configuration, public_key_map, priv_key_map['tail'],
        signing_key_map['tail'], verify_key_hex_map, 'tail', 'ACTIVE', head_timeout, nonhead_timeout, checkpt_interval))
        start(configuration['head'])
        start(configuration['tail'])

        #setup and start intermediate replicas
        for index in range(1, len(configuration) - 1):
            setup(configuration['replica_' + str(index)], (self, configuration, public_key_map, priv_key_map['replica_'
            + str(index)], signing_key_map['replica_' + str(index)], verify_key_hex_map, 'replica_' + str(index), 'ACTIVE', head_timeout, nonhead_timeout, checkpt_interval))
            start(configuration['replica_' + str(index)])    


def main():
    print('Olympus main method')
