from nacl.public import PrivateKey, Box
import nacl.encoding
import nacl.hash
import nacl.signing
import pickle
import logging
import time
from math import floor
from nacl.bindings.utils import sodium_memcmp
import datetime
import os

# config(channel is fifo, clk is lamport)
config(channel = 'fifo')
config(clock = 'lamport')

olympus    = import_da('olympus')
client     = import_da('client')
messages   = import_da('messages')
operations = import_da('operations')
sign = import_da('sign')
read_config_file = import_da('read_config_file')


#Note: For phase 2 only one configuration is supported
def handle_failure_trigger(replica_id, client_id, sequence_number, failure_scenario_properties, failure_trigger,
config_id='config_0'):
    failure_error = None
    #all failures from config file are commented
    if len(failure_scenario_properties) == 0:
        return failure_error

    if client_id is None:
        tuple = str(sequence_number)
    else:
        tuple = str(client_id) + ',' + str(sequence_number)
    if replica_id in failure_scenario_properties[config_id].keys():
        for tuples in failure_scenario_properties[config_id][replica_id]:
            if(tuple == tuples[0] and failure_trigger == tuples[1]):
                failure_error = tuples[2]
    return failure_error


def handle_failure_error(failure_error):
    failure_error_dict = {'operation':None, 'result':False, 'drop_result':False, 'crash':False, 'truncate_history':None,
    'sleep':None, 'increment_slot':False, 'drop':False, 'extra_op':False, 'invalid_order_sig':False,
    'invalid_result_sig':False}
    if 'change_operation' in failure_error:
        failure_error_dict['operation'] = "get('x')"
    elif 'change_result' in failure_error:
        failure_error_dict['result'] = True
    elif 'drop_result_stmt' in failure_error:
        failure_error_dict['drop_result'] = True
    elif 'crash' in failure_error:
        failure_error_dict['crash'] = True
    elif 'truncate_history' in failure_error:
        n = int(failure_error.split('(')[1].split(')')[0])
        failure_error_dict['truncate_history'] = n
    elif 'sleep' in failure_error:
        n = int(failure_error.split('(')[1].split(')')[0])
        failure_error_dict['sleep'] = n
    elif 'increment_slot' in failure_error:
        failure_error_dict['increment_slot'] = True
    elif 'drop' in failure_error:
        failure_error_dict['drop'] = True
    elif 'extra_op' in failure_error:
        failure_error_dict['extra_op'] = True
    elif 'invalid_order_sig' in failure_error:
        failure_error_dict['invalid_order_sig'] = True
    elif 'invalid_result_sig' in failure_error:
        failure_error_dict['invalid_result_sig'] = True
    else:
        print("Unhandled failure error scenario")
    return failure_error_dict


def dump_expected_result(dictionary, client_id):
    fname = "testcase_" + str(client_id) + "_result.txt"
    testing_file = open(fname, "wb")
    pickle.dump(dictionary, testing_file, pickle.HIGHEST_PROTOCOL)
    testing_file.close()

class Replica(process):
    #setup replica
    #set the replica id, public and private keys

    def setup(olympus:olympus.Olympus, config:dict, public_key_map:dict, priv_key:PrivateKey,
    signing_key:cl.signing.SigningKey, verify_key_hex_map:dict, replica_id:int, mode:str, head_timeout:int, nonhead_timeout:int,
    checkpt_interval: int):
        self.dictionary = {}
        self.cache = {}
        self.failure_scenario_properties = {}
        self.slot_number = 0
        self.history = []
        self.inprogress_operations = {}
        self.count = 0
        self.request_forwarded = False

        self.latest_result_stmt = {}

        #store latest checkpoint proof, this will be included in the wedged statement
        self.checkpoint_proof = None
        self.state_to_save = {}
        self.latest_checkpoint_proof = None
        # self.checkpoint_slot = 1
        self.cached_checkpoint_shuttles = {}
        self.kill = False
        output('Replica', replica_id, ' setup')

    """""""""""""""""""""
        Checkpointing
    """""""""""""""""""""
    # calculate hash of the running state (i.e. current contents of the dictionary)
    # all replicas will do the same, tail will do the same and send the checkpoint shuttle in the reverse direction
    def initiate_checkpoint():
        output('Head initiating checkpoint')        
        hashed_running_state = sign.generate_hash(pickle.dumps(state_to_save[slot_number]))
        output('head saving dict ', state_to_save, hashed_running_state)
        checkpoint_statement = messages.CheckpointStatement('checkpoint', hashed_running_state)
        signed_stmt = sign.sign_msg(signing_key, pickle.dumps(checkpoint_statement))

        checkpoint_proof = messages.Proof(signed_stmt, slot_number, None, None, None)

        checkpoint_shuttle = messages.Shuttle(None, 'head', config['replica_1'], None)
        checkpoint_shuttle.add_checkpoint_proof(checkpoint_proof)

        send(('CheckpointShuttle', checkpoint_shuttle, replica_id, slot_number), to=config['replica_1'])

        # always return false to keep the await statement waiting
        return False


    def delete_history_prefix(checkpoint_proof, replica_id):
        slot = checkpoint_proof.slot
        output('Replica', replica_id,'Previous length of history: ', len(history))
        output('Previous history :: ')
        for index in range(0, len(history)):
            output('Replica', replica_id, ': slot, op', history[index].slot, history[index].operation)
        history = history[slot:]
        latest_checkpoint_proof = checkpoint_proof
        output('Replica', replica_id,' latest checkpoint proof: ', latest_checkpoint_proof)
        output('Replica', replica_id,'Current length of history: ', len(history), ' current history::', history)
        for index in range(0, len(history)):
            output('Replica', replica_id, ': slot, op', history[index].slot, history[index].operation)


    #TO-DO: find if verify_sign is used too many times and make into a method
    # try to reuse verify_signed_order_statements from line 294
    def receive(msg=('CheckpointShuttle', checkpoint_shuttle, s_replica_id, head_slot), from_=head):
        # when the shuttle is received, if slot_number != checkpt_interval
        # add shuttle to cache
        output('Replica', replica_id, 'received checkpoint shuttle from', s_replica_id, 'slot number is', slot_number)
        if slot_number < checkpt_interval or not slot_number % checkpt_interval == 0:
            output('Replica', replica_id, 'received checkpoint shuttle, slot_number is', slot_number,'. Caching the shuttle')
            cached_checkpoint_shuttles[head_slot] = checkpoint_shuttle
        else:
            output('Replica', replica_id, 'Processing checkpoint shuttle, state of dictionary', dictionary, 'saving', state_to_save, 'time:: ', datetime.datetime.now())
            result = process_checkpoint_shuttle(checkpoint_shuttle, s_replica_id)
            output('Received result', result, 'after processing checkpoint shuttle', replica_id)


    def process_checkpoint_shuttle(checkpoint_shuttle, s_replica_id):
        verified = True
        if not replica_id == 'tail':
            my_index = int(replica_id.split('_')[1])
        else:
            my_index = len(config) - 1
        index = 0
        checkpoint_statements = checkpoint_shuttle.checkpoint_proof.statements
        checkpoint_slot = checkpoint_shuttle.checkpoint_proof.slot

        result = sign.verify_sign(verify_key_hex_map['head'], checkpoint_statements[index])
        if not result == None:
            for index in range(1, my_index):
                result = sign.verify_sign(verify_key_hex_map['replica_' + str(index)], checkpoint_statements[index])
                if result == None:
                    verified = False
                    break
        if verified:
            hashed_running_state = sign.generate_hash(pickle.dumps(state_to_save[checkpoint_slot]))
            output('Replica ', replica_id, ' saving dict ', state_to_save, hashed_running_state)
            checkpoint_statement = messages.CheckpointStatement('checkpoint', hashed_running_state)
            signed_stmt = sign.sign_msg(signing_key, pickle.dumps(checkpoint_statement))
            checkpoint_shuttle.checkpoint_proof.add_statement(signed_stmt)
            output('forwarding checkpoint shuttle')
            if  not replica_id == 'tail' and my_index == len(config) - 2:
                send(('CheckpointShuttle', checkpoint_shuttle, replica_id, slot_number), to=config['tail'])
            elif not replica_id == 'tail':
                send(('CheckpointShuttle', checkpoint_shuttle, replica_id, slot_number), to=config['replica_' + str(my_index + 1)])
        else:
            output('Replica', replica_id, 'detected incorrect signature while verifying signature on checkpoint statement. Sending reconfiguration request')
            send(('ReconfigurationRequest', 'invalid checkpoint statement ', None, -1, -1, replica_id,), to=olympus)

        if replica_id == 'tail':
            output('Replica Tail: completed checkpoint')
            send(('ReverseCheckpointShuttle', checkpoint_shuttle, replica_id,), to=config['replica_' + str(len(config) - 2)])
            delete_history_prefix(checkpoint_shuttle.checkpoint_proof, replica_id)
        return verified


    def receive(msg=('ReverseCheckpointShuttle', checkpoint_shuttle, s_replica_id,), from_=replica):
        output('Replica', replica_id, 'received reverse checkpoint shuttle from', s_replica_id)

        checkpoint_statements = checkpoint_shuttle.checkpoint_proof.statements
        checkpoint_slot = checkpoint_shuttle.checkpoint_proof.slot
        output('Replica', replica_id, ' inside reverse checkpoint shuttle. checking slot', checkpoint_slot)
        verified = True
        if not replica_id == 'head':
            my_index = int(replica_id.split('_')[1])

        output('inside reverse checkpoint shuttle', replica_id, 'saved state', state_to_save)
        #Validate order proof with previous
        verified = verify_proof(checkpoint_shuttle.checkpoint_proof, pickle.dumps(state_to_save[checkpoint_slot]), 'checkpoint')

        if not verified:
            output('Replica', replica_id, 'detected incorrect signature while verifying signature on checkpoint statement.\
                Sending reconfiguration request')
            send(('ReconfigurationRequest', 'invalid checkpoint statement ', None, -1, -1, replica_id,), to=olympus)
        else:
            #send checkpoint shuttle to the previous replica
            if replica_id == 'head':
                delete_history_prefix(checkpoint_shuttle.checkpoint_proof, replica_id)
                output('Replica', replica_id, 'deleted history prefix')
                return
            elif (replica_id == 'replica_1'):
                send(('ReverseCheckpointShuttle', checkpoint_shuttle, replica_id,), to=config['head'])                
                delete_history_prefix(checkpoint_shuttle.checkpoint_proof, replica_id)
                output('Replica', replica_id, 'deleted history prefix')
            else:
                send(('ReverseCheckpointShuttle', checkpoint_shuttle, replica_id,), to=config['replica_' + str(my_index - 1)])
                delete_history_prefix(checkpoint_shuttle.checkpoint_proof, replica_id)
                output('Replica', replica_id, 'deleted history prefix', replica_id)


    #start the replica, it is in continuous wait state
    def run():
        start_time = time.time()
        output('Replica:', replica_id,'started in', mode, 'mode')
        failure_scenario_properties = read_config_file.get_failure_scenario_properties()

        await(kill)
        # output('After await. Replicas exiting..')
        # os._exit(-1)
        # sys.exit()

    """""""""""""""""""""""""""
        Methods for shuttles
    """""""""""""""""""""""""""
    #replica head: add operation at that slot
    def order_operation(operation, client, client_id, sequence_number):
        forward_shuttle = None
        slot_number = slot_number + 1
        verified = check_history(history, slot_number, operation, replica_id)
        if not verified:
            output('Replica Head: detected invalid slot and operation in previous order proofs. Aborting..')
        else:
            output('Replica', replica_id, ': successfully verified previous order statements')
            order_statement = messages.OrderStatement('order', slot_number, operation)    # <'order', slot, operation>
            signed_order_statement = sign.sign_msg(signing_key, pickle.dumps(order_statement))

            order_proof = messages.Proof(signed_order_statement, slot_number, operation, sequence_number, client_id)

            forward_shuttle = messages.Shuttle(order_proof, 'head', config['replica_1'], client)
            history.append(order_proof)
            output('Replica Head: Added operation', operation, 'at slot', slot_number)

            if slot_number == checkpt_interval or slot_number % checkpt_interval == 0 and not slot_number == 0:
                output('initiating checkpoint for slot', slot_number)
                state_to_save[slot_number] = dictionary.copy()
                initiate_checkpoint()
        return forward_shuttle


    #check order proofs and statements in order proofs in history
    def check_history(history, slot_number, operation, replica_index):
        verified = True
        for order_proof in history:
            #for any previous order proofs, if the slot number was incorrect
            if order_proof.slot == slot_number or order_proof.slot > slot_number:
                verified = False
                output('Replica', replica_id, 'detected invalid slot and operation for operation in previous order proof:', operation)
                break
            else: #check all order statements in previous order proofs
                verfied = verify_all_order_statements(order_proof, slot_number, operation, replica_index)
        output('Replica', replica_index,': Verified history')
        return verified


    #for any replica, check all order statements for validity in this order proof
    def verify_all_order_statements(order_proof, slot_number, operation, replica_index):
        order_statements = order_proof.statements
        index = 0
        verified = True

        #for an order proof in head's history, there should be 1 order statement present
        if replica_index == 'head' and len(order_statements) == 0:
            verified = False
        #for an order proof in intermediate and tail replica's history, there should be order statements from all previous replicas
        elif not replica_index == 'head' and not replica_index == 'tail' and not len(order_statements) == replica_index:
            verified = False
        elif replica_index == 'tail' and not len(order_statements) == len(config) - 1:
            verified = False

        #verify signatures on all previous order statements in history
        order_stmt = sign.verify_sign(verify_key_hex_map['head'], order_statements[index])
        order_stmt = pickle.loads(order_stmt)
        if order_stmt.slot == slot_number or order_stmt.slot > slot_number:
            verified = False

        if verified and not replica_index == 'head':
            for index in range(1, len(order_statements)):
                order_stmt = sign.verify_sign(verify_key_hex_map['replica_' + str(index)], order_statements[index])
                order_stmt = pickle.loads(order_stmt)
                if order_stmt.slot == slot_number or order_stmt.slot > slot_number:
                    verified = False
                    break
        return verified


    #check previous order statements for the current operation execution
    def check_previous_statements(unsigned_order_statements, slot, operation):
        verified = True
        output('unsigned order stmt', unsigned_order_statements)
        for statement in unsigned_order_statements:
            output('statement in check previous stmts', statement.slot, statement.operation, 'incoming values ', slot, operation)
            if not (statement.slot == slot and statement.operation == operation):
                output('Replica', replica_id, 'detected invalid slot and operation while checking prev order statements for ',  slot, operation)
                verified = False
                break
        return verified


    #replica intermediate: add order statement to order proof contained in the forward shuttle
    def add_order_statement(forward_shuttle, operation, replica_index, invalidate_order=False):
        # if slot_number % checkpoint_slot ==0 and not slot_number == 0:
        verified = True
        slot_number += 1
        verified = check_history(history, slot_number, operation, replica_index)
        if verified:
            verified = verify_signed_order_statements(forward_shuttle.order_proof, replica_index, slot_number, operation)
        if verified:
            output('Replica', replica_id, ': successfully verified previous order statements')
            order_statement = messages.OrderStatement('order', slot_number, operation)
            signed_order_statement = sign.sign_msg(signing_key, pickle.dumps(order_statement))
            if invalidate_order:
                signed_order_statement_list = list(signed_order_statement)
                signed_order_statement_list[0] = (signed_order_statement_list[0] + 1) % 256
                newsigned = bytes(signed_order_statement_list)
                signed_order_statement = nacl.signing.SignedMessage._from_parts(signed_order_statement._signature, signed_order_statement._message, newsigned)
            order_proof = forward_shuttle.order_proof            
            order_proof.add_statement(signed_order_statement)
            history.append(order_proof)

            output('Replica', replica_id, 'performing operation', operation, ' dictionary previously', dictionary, 'slot number now', slot_number)

            if slot_number == checkpt_interval or slot_number % checkpt_interval == 0 and not slot_number == 0:
                state_to_save[slot_number] = dictionary.copy()
                output('Replica', replica_index, 'Dictionary being saved', state_to_save, dictionary, 'time:: ', datetime.datetime.now())

        else:
            #send reconfig request
            output('Invalid order proof detected at replica', replica_id)
        return verified


    #check signature and content of previous order statements for the current operation execution
    def verify_signed_order_statements(order_proof, replica_index, slot_number, operation):
        order_statements = order_proof.statements
        index = 0
        unsigned_order_statements = []        
        result = sign.verify_sign(verify_key_hex_map['head'], order_statements[index])
        verified = True

        if result == None:
            verified = False
        else:
            result = pickle.loads(result)            
            unsigned_order_statements.append(result)

        if not replica_index == 'head':
            if replica_index == 'tail':
                replica_index = len(config)
                map_key = 'replica_'
                for index in range(1, replica_index):
                    result = sign.verify_sign(verify_key_hex_map[map_key + str(index)], order_statements[index])

                    if result == None:
                        verified = False
                        break
                    else:
                        result = pickle.loads(result)
                        unsigned_order_statements.append(result)

        verified = check_previous_statements(unsigned_order_statements, slot_number, operation)
        return verified


    def verify_statement(verify_key, signed_statement, hashed_result, type):
        verified = True
        statement = None
        verified_statement = sign.verify_sign(verify_key, signed_statement)
        if verified_statement == None:
            verified = False
            return verified
        if verified:
            statement = pickle.loads(verified_statement)
        if not sodium_memcmp(hashed_result, statement.hash):
            output('Replica', replica_id ,'hash values ', hashed_result, statement.hash)
            output('Replica ', replica_id, ': The hash of objects did not match ', type)
            verified = False
        return verified


    def verify_proof(proof, result, type):
        output('Replica', replica_id,'Dictionary being compared', type, result, state_to_save, proof.slot)
        #verify hash
        hashed_result = sign.generate_hash(result)
        statements = proof.statements
        verified = True

        output('Replica', replica_id, 'Verifying', type, 'proof')
        verified = verify_statement(verify_key_hex_map['head'], statements[0], hashed_result, type)
        if not verified:
            output("Replica :",replica_id, "Signature verification failed for result proof.")
            return False

        index = 1
        for statement in statements[1:-1]:
            verified = verify_statement(verify_key_hex_map['replica_' + str(index)], statement, hashed_result, type)
            if not verified:
                break
            index += 1
        verified = verify_statement(verify_key_hex_map['tail'], statements[-1], hashed_result, type)
        if verified:
            output('Replica', replica_id ,'Hash of objects matched for ', type)
        return verified


    #create result shuttle, done by the head replica
    def create_result_proof(result, slot, operation, sequence_number, client_id):
        hashed_result = sign.generate_hash(result.encode('ascii'))
        result_statement = messages.ResultStatement('result', result, hashed_result, operation)

        #TO-DO: sign result statement before adding to proof
        signed_result_statement = sign.sign_msg(signing_key, pickle.dumps(result_statement))
        result_proof = messages.Proof(signed_result_statement, slot, operation, sequence_number, client_id)
        return result_proof, signed_result_statement


    #add result statement to result proof contained in the result shuttle
    def add_result_statement(shuttle, operation, result, hashed_result, invalidate_result=False):
        #TO-DO: sign result statement before adding to proof
        result_statement = messages.ResultStatement('result', result, hashed_result, operation)
        signed_result_statement = sign.sign_msg(signing_key, pickle.dumps(result_statement))
        if invalidate_result:
            signed_result_statement_list = list(signed_result_statement)
            signed_result_statement_list[0] = (signed_result_statement_list[0] + 1) % 256
            newsigned = bytes(signed_result_statement_list)
            signed_result_statement = nacl.signing.SignedMessage._from_parts(signed_result_statement._signature,
            signed_result_statement._message, newsigned)
 
        result_proof = shuttle.result_proof
        result_proof.add_statement(signed_result_statement)
        return signed_result_statement

    #cache result and result shuttle at each replica
    def cache_result(result_shuttle, result, client, sequence_number, client_id):
        cache[str(client_id) + '_' + str(sequence_number)] = (result_shuttle, result)


    """""""""""""""""""""""""""
        Receive Handlers
    """""""""""""""""""""""""""

    # send the decrypted signed operation to the next replica
    # don't send the encrypted operation, it has been encrypted with head's public key

    #Head Replica
    def receive(msg=('ClientRequest', client_request, operation_hex, client_id, retransmit_req,), from_=client):
        if mode == 'IMMUTABLE':
            output('Replica head: Immutable, sending error to client')
            send(('ErrorStatement', replica_id,), to=client)
        else:
            replica_box = Box(priv_key, public_key_map['client_'+ str(client_id)])

            #verify that the operation really came from that particular client
            # (operation, sequence_number, client_id)  = sign.verify_msg(encrypted_operation, replica_box, operation_hex,
            # verify_key_hex_map['client_'+str(client_id)])
            verified_obj, received_msg  = sign.verify_msg(client_request, replica_box, operation_hex,
            verify_key_hex_map['client_' + str(client_id)])

            operation, sequence_number, s_client_id = pickle.loads(verified_obj)

            if not operation == None:
                output("Replica Head: operation received from client :", operation)

                #Check for failure trigger condition
                failure_error = handle_failure_trigger('replica_0', client_id, sequence_number, failure_scenario_properties,'client_request')
                output("failure_error :", failure_error)
                if failure_error:
                    failure_error_dict = handle_failure_error(failure_error)

# <<<<<<< HEAD
#                 if failure_error and failure_error_dict['operation']:
#                     operation = failure_error_dict['operation']
#                     output("Injecting failure change operation on head replica")

# =======
                    if failure_error_dict['operation']:
                        operation = failure_error_dict['operation']
                        output("Injecting failure change operation on head replica")
                    elif failure_error_dict['increment_slot'] == True:
                        slot_number += 2
                        output("Injecting failure of incrementing slot to ", slot_number)

                forward_shuttle = start_new_operation(operation, client, client_id, sequence_number)

                #send the forward shuttle, result shuttle to the next replica
                if not retransmit_req and not forward_shuttle == None:
                    send(('ForwardShuttle', forward_shuttle, received_msg, client, client_id, sequence_number), to=config['replica_1'])
                elif forward_shuttle == None:
                    output('Replica', replica_id, 'Incorrect behaviour detected. Send reconfiguration request to Olympus')
                    send(('ReconfigurationRequest', 'invalid order proof at head', operation, sequence_number, client_id, replica_id,), to=olympus)
                else:
                    output("Retransmit failure injected hence not sending forward shuttle.")


    def receive(msg=('ResultShuttle', result_shuttle, result, sequence_number, client_id, operation, ), from_=replica):
        output('Replica :', replica_id, 'result shuttle received from previous replica :', result_shuttle)
        if replica_id != 'head':
            my_index = int(replica_id.split('_')[1])

        #Check for failure trigger condition
        failure_error = handle_failure_trigger(replica_id, client_id, sequence_number, failure_scenario_properties, 'result_shuttle')
        if failure_error:
            failure_error_dict = handle_failure_error(failure_error)
            output("failure error dict :", failure_error_dict)
            if failure_error_dict['result']:
                output("Replica :",replica_id, "Injecting result shuttle failure.")
                result = "FAIL"
            elif failure_error_dict['drop_result']:
                output("Replica :", replica_id, "Injecting drop result statement failure.")
                result_shuttle.result_proof.statements.pop(0)

        #Validate order proof with previous
        verified = verify_proof(result_shuttle.result_proof, result.encode('ascii'), 'result')
        if not verified:
            output('Replica', replica_id, 'Result proof received is invalid sending reconfig request to olympus')
            send(('ReconfigurationRequest', 'invalid result proof', operation, sequence_number, client_id,
            replica_id, ), to=olympus)
            #send(('ReconfigurationRequest', 'invalid checkpoint statement ', None, -1, -1, replica_id,), to=olympus)
        else:
            output('Replica', replica_id, 'Result proof validated successfully')

            #cache result and result shuttle
            cache_result(result_shuttle, result, client, sequence_number, client_id)
            output('Replica', replica_id, ': cached result', cache)
            #send result shuttle to the previous replica
            if replica_id == 'head':
                return
            elif (replica_id == 'replica_1'):
                send(('ResultShuttle', result_shuttle, result, sequence_number, client_id, operation, ), to=config['head'])
                output('Replica', replica_id ,': Sent result shuttle to head')
            else:
                send(('ResultShuttle', result_shuttle, result, sequence_number, client_id, operation, ), to=config['replica_' + str(my_index - 1)])
                output('Replica', replica_id ,': Sent result shuttle to', 'replica_' + str(my_index - 1))

            # this checks if the current operation was retransmitted from the client
            # if yes, this replica will send the result to the client
            try:
                value = inprogress_operations[(client_id, sequence_number, operation)]
                # client = config[client_id]
                output('Replica', replica_id, ': sending result for retransmitted request with sequence number', sequence_number)
                send(('RetransmitResult', result_shuttle.result_proof, result, str(client_id) + '_' + str(sequence_number) + '_' + 'resent', operation, ), to=config[client_id])
            except KeyError:
                pass


    #Intermediate replicas
    def receive(msg=('ForwardShuttle', forward_shuttle, client_request, client, client_id, sequence_number), from_=replica):
        output('Replica Intermediate:', replica_id, 'shuttle received from previous replica :', forward_shuttle)
        my_index = int(replica_id.split('_')[1])
        
        if mode == 'IMMUTABLE':
            output('Replica :",replica_id, "Immutable, not performing forward shuttle operation.')
            return

        #Check for failure trigger condition
        invalidate_order_statement = False
        failure_error = handle_failure_trigger(replica_id, client_id, sequence_number,
        failure_scenario_properties,'shuttle')
        output("failure_error :", failure_error)
        if failure_error:
            failure_error_dict = handle_failure_error(failure_error)
            if failure_error_dict['result']:
                output("Injecting result shuttle failure.")
                result = "FAIL"
            elif failure_error_dict['drop_result']:
                output("Injecting drop head result statement failure.")
                result_shuttle.result_proof.statements.pop(0)
            elif failure_error_dict['sleep'] is not None:
                output("Injecting sleep error at replica ", replica_id, " for time :", failure_error_dict['sleep'])
                time.sleep(failure_error_dict['sleep'])
            elif failure_error_dict['invalid_order_sig'] == True:
                output("Injecting invalid order signature at replica ", replica_id)
                invalidate_order_statement = True

        unsigned_obj = sign.verify_sign(verify_key_hex_map['client_' + str(client_id)], client_request)
        operation, sequence_number, s_client_id = pickle.loads(unsigned_obj)

        # replica_box = Box(priv_key, public_key_map['client_'+ str(client_id)])
        # #verify that the operation really came from that particular client        

        # output('Before verify')
        # verified_obj  = sign.verify_msg(client_request, replica_box, operation_hex,
        # verify_key_hex_map['client_'+str(client_id)])
        # output('after verify')

        # operation, sequence_number, s_client_id = pickle.loads(verified_obj)
        # output('after loading')
        #add order statement to the order proof in the shuttle
        success = add_order_statement(forward_shuttle, operation, my_index, invalidate_order_statement)
        if success:
            output('Replica:', replica_id, 'orderCommand transition')
            forward_shuttle.update_sender(config['replica_' + str(my_index)])

            #applying operation to running state and add result statement to the result shuttle
            result = operations.perform_operation(operation, dictionary)
            output('State of dictionary at', 'replica_' + str(my_index),':', dictionary, 'after operation', operation)
            signed_result_statement = add_result_statement(forward_shuttle, operation, result, sign.generate_hash(result.encode('ascii')))

            if not client_id in latest_result_stmt:
                latest_result_stmt[client_id] = {}
            latest_result_stmt[client_id][(operation, sequence_number)] = signed_result_statement

            #send both shuttles to next replica
            if  my_index == len(config) - 2:
                send(('TailRequest', forward_shuttle, client_request, client, client_id, sequence_number), to=config['tail'])
            else:                                                                                                                                                           
                send(('ForwardShuttle', forward_shuttle, client_request, client, client_id, sequence_number), to=config['replica_' + str(my_index + 1)])

            output('Replica', replica_id, 'trying to get cached checkpoint shuttles', cached_checkpoint_shuttles)

            # check if any checkpoint shuttle is cached, if yes process it
            if (slot_number == checkpt_interval or slot_number % checkpt_interval == 0) and not slot_number == 0 and len(cached_checkpoint_shuttles) > 0:
                verified = process_checkpoint_shuttle(cached_checkpoint_shuttles[slot_number], replica_id)
                del cached_checkpoint_shuttles[slot_number]
                # except KeyError:
                #     output('Something went wrong while trying to get the cached checkpoint shuttle')
        else:
            output('Replica', replica_id, 'Incorrect behaviour was detected. Send reconfiguration request to Olympus')
            send(('ReconfigurationRequest', 'invalid order proof', operation, sequence_number, client_id, replica_id,), to=olympus)


    #Tail Replica
    def receive(msg=('TailRequest', forward_shuttle, client_request, client, client_id,sequence_number, ), from_=replica):
        output('Replica Tail: shuttle received in tail replica :', forward_shuttle)

        if mode == 'IMMUTABLE':
            output('Replica :",replica_id, "Immutable, not performing forward shuttle operation.')
            return

        #Check for failure trigger condition
        tmp_replica_id = 'replica_' + str(len(config))
        failure_error = handle_failure_trigger(tmp_replica_id, client_id, sequence_number,
        failure_scenario_properties,'shuttle')
        output("failure_error :", failure_error)
        invalidate_result = False
        if failure_error:
            failure_error_dict = handle_failure_error(failure_error)
            if failure_error_dict['invalid_result_sig'] == True:
                output("Replica Tail: Injecting failure error for invalidating result statement signature.")
                invalidate_result = True

        unsigned_obj = sign.verify_sign(verify_key_hex_map['client_' + str(client_id)], client_request)
        operation, sequence_number, s_client_id = pickle.loads(unsigned_obj)

        # replica_box = Box(priv_key, public_key_map['client_'+ str(client_id)])
        # #verify that the operation really came from that particular client        
        # verified_obj  = sign.verify_msg(client_request, replica_box, operation_hex,
        # verify_key_hex_map['client_'+str(client_id)])

        # operation, sequence_number, s_client_id = pickle.loads(verified_obj)

        # add order statement to the order proof in the shuttle
        # 3rd arg here is len(configuration) instead of 'tail', b/c we loop
        # on that arg in the called method
        success = add_order_statement(forward_shuttle, operation, len(config) - 2)
        if success:
            output('Replica:', replica_id, 'orderCommand transition')
            output('Replica:', replica_id, 'added order statement to shuttle.(', slot_number, ', ', operation, ') is persistent')

            #applying operation to running state and add result statement to the result shuttle
            result = operations.perform_operation(operation, dictionary)
            output('State of dictionary at Tail:', dictionary)

            signed_result_statement = add_result_statement(forward_shuttle, operation, result, sign.generate_hash(result.encode('ascii')), invalidate_result)

            if not client_id in latest_result_stmt:
                latest_result_stmt[client_id] = {}
            latest_result_stmt[client_id][(operation, sequence_number)] = signed_result_statement

            #the order proof is complete, send result to client
            send(('Result', forward_shuttle.result_proof, result, str(client_id) + '_' + str(sequence_number), operation), to=client)
            output("Tail Replica: sent reply to client", client)
            dump_expected_result(dictionary, client_id)

            #cache result and result shuttle
            cache_result(forward_shuttle, result, client, sequence_number, client_id)
            output('Replica', replica_id, ': cached result:', cache)

            #send the shuttle in the reverse direction
            send(('ResultShuttle', forward_shuttle, result, sequence_number, client_id, operation, ), to=config['replica_' +
            str(len(config) - 2)])
            output('Replica', replica_id ,': Sent result shuttle to', 'replica_' + str(len(config) - 2))

            # check if any checkpoint shuttle is cached, if yes process it
            if (slot_number == checkpt_interval or slot_number % checkpt_interval == 0) and not slot_number == 0 and len(cached_checkpoint_shuttles) > 0:
                output('Replica', replica_id, 'trying to get cached checkpoint shuttles', cached_checkpoint_shuttles)
                verified = process_checkpoint_shuttle(cached_checkpoint_shuttles[slot_number], replica_id)
                del cached_checkpoint_shuttles[slot_number]
                # except KeyError:
                #     output('Something went wrong while trying to get the cached checkpoint shuttle')
        else:
            output('Replica', replica_id, 'Incorrect behaviour was detected. Send reconfiguration request to Olympus')
            send(('ReconfigurationRequest', 'invalid order proof at tail', operation, sequence_number, client_id, replica_id,), to=olympus)


    #handler for retransmitted request from client after timeout
    def receive(msg=('ReTransmittedRequest', encrypted_operation, operation_hex, sequence_number, client_id), from_=client):
        if mode == 'IMMUTABLE':
            output('Replica', replica_id, 'is Immutable. Sending error statement to client')
            send(('ErrorStatement', replica_id,), to=client)

        replica_box = Box(priv_key, public_key_map['client_' + str(client_id)])

        # operation = sign.verify_msg(encrypted_operation, replica_box, operation_hex, verify_key_hex_map['client_'+ str(client_id)])
        verified_obj, received_msg = sign.verify_msg(encrypted_operation, replica_box, operation_hex, verify_key_hex_map['client_'+ str(client_id)])
        output('Before load', verified_obj)
        operation, sequence_number, s_client_id = pickle.loads(verified_obj)
        output('After load')
        if not operation == None:
            output('Replica', replica_id,': retransmit request received from client for operation:', operation.encode('ascii'), 'sequence number:', sequence_number)
            output('Replica', replica_id, ': and cache is', cache)
            result = cache.get(str(client_id) + '_' + str(sequence_number))

            if not result == None:  #if the result is present in cache, send to client
                result_proof = result[0].result_proof
                output('Replica', replica_id, ': sending result for retransmitted request with sequence number', sequence_number)
                send(('RetransmitResult', result_proof, result[1], str(client_id) + '_' + str(sequence_number) + '_' + 'resent', operation), to=client)

            elif result == None and not replica_id == 'head': #if result not found in cache, forward to head
                output('Replica', replica_id, 'did not find result cached. Forwarding request to head..')
                send(('ForwardRequest', received_msg, sequence_number, client_id, client, replica_id), to=config['head'])
                inprogress_operations[(client_id, sequence_number, operation)] = time.time()

                #poll timeout here
                if await(get_result(client_id, sequence_number)):
                    result = cache.get(str(client_id) + '_' + str(sequence_number))
                    result_proof = result[0].result_proof
                    send(('RetransmitResult', result_proof, result[1], str(client_id) + '_' + str(sequence_number) + '_' + 'resent', operation), to=client)
                    found = True
                    #break
                elif timeout(nonhead_timeout/1000):
                    output('Replica', replica_id,'timed out waiting for the result shuttle in retransmission after forwarding request to head. Sending reconfig request..')
                    send(('ReconfigurationRequest', 'timeout at intermediate replica in retransmitted request', operation, sequence_number, client_id, replica_id,), to=olympus)
        else:
            output('Replica', replica_id, 'There was an error in decrypting the operation')


    def get_result(client_id, sequence_number):
        result = cache.get(str(client_id) + '_' + str(sequence_number))
        if not result == None:
            return True
        return False


    #handler for retransmitted requests forwarded from other replicas to head
    def receive(msg=('ForwardRequest', client_request, sequence_number, client_id, client, replica_id), from_=replica):
        output('Replica head received forwarded retransmitted request from Replica', replica_id)
        result = cache.get(str(client_id) + '_' + str(sequence_number))
        timed_out = False
        found = False
        timer_started = False
        reconfig = False
        if not result == None:
            result_proof = result[0].result_proof
            output('Replica', replica_id, ': sending result for retransmitted request with sequence number', sequence_number)
            send(('RetransmitResult', result_proof, result[1], str(client_id) + '_' + str(sequence_number) + '_' + 'resent', operation), to=client)
        else:
            unsigned_obj = sign.verify_sign(verify_key_hex_map['client_' + str(client_id)], client_request)
            output('Before load in fwd req')
            operation, sequence_number, s_client_id = pickle.loads(unsigned_obj)
            output('After load in fwd req')
            for order_proof in history:
                try:
                    value = inprogress_operations[(client_id, sequence_number, operation)]
                    if not value == 0:
                        timer_started = True
                except KeyError:
                    timer_started = False

                if order_proof.operation == operation and not timer_started:
                    output('Replica head: previously started', operation, 'at', order_proof.slot, '. Waiting for result. Starting timer on request from replica', replica_id)
                    inprogress_operations[(client_id, sequence_number, operation)]  = time.time()
                    #poll timeout here
                    if await(get_result(client_id, sequence_number)):
                        result = cache.get(str(client_id) + '_' + str(sequence_number))
                        result_proof = result[0].result_proof
                        send(('RetransmitResult', result_proof, result[1], str(client_id) + '_' + str(sequence_number) + '_' + 'resent', operation), to=client)
                        found = True
                        break
                    elif timeout(head_timeout/1000):
                        output('Replica head timed out waiting for the result shuttle in retransmission. Sending reconfig request..')
                        timer_started = False
                        reconfig = True
                        send(('ReconfigurationRequest', 'timeout', operation, sequence_number, client_id, replica_id,), to=olympus)
                        break
                elif timer_started:
                    output('Replica head: Already started timer for this retransmission request, ignoring the request from replica', replica_id)
            if not found and not reconfig and not timer_started:
            # if not found:
            #else start the operation from scratch
                #add operation at the next slot
                output('starting new operation', operation, 'on request from replica', replica_id)
                forward_shuttle = start_new_operation(operation, client, client_id, sequence_number)
                #send the forward shuttle, result shuttle to the next replica
                send(('ForwardShuttle', forward_shuttle, operation, client, sequence_number, client_id,), to=config['replica_1'])

    def receive(msg=('WedgeRequest', sequence_no), from_=olympus):
        #Check for failure trigger condition
        failure_error = handle_failure_trigger(replica_id, None, sequence_no, failure_scenario_properties,'wedge_request')
        output("failure_error :", failure_error)
        if failure_error:
            failure_error_dict = handle_failure_error(failure_error)
            if failure_error_dict['crash'] == True:
                output("Replica ", replica_id, " is crashing due to fault injection.")
                logging.shutdown()
                os._exit(1)
            elif failure_error_dict['truncate_history'] is not None:
                output("Replica ", replica_id, ": truncating last ", failure_error_dict['truncate_history'], " statements from history.")
                history = history[:-failure_error_dict['truncate_history']]
        mode = 'IMMUTABLE'
        output('Replica', replica_id, 'changed mode to IMMUTABLE on receiving wedge request from Olympus')

        wedged_statement = messages.WedgedStatement('WedgedStatement', history, latest_checkpoint_proof, dictionary)
        signed_wedged_statement = sign.sign_msg(signing_key, pickle.dumps(wedged_statement))
        output("Replica ", replica_id, ": sending wedged statement to olympus.")
        send(('WedgedStatement', signed_wedged_statement, replica_id,), to=olympus)


    def receive(msg=('CatchupStatement', catchup_statement, client_id, sequence_no), from_=olympus):
# =======
#     def receive(msg=('CatchupStatement', catchup_statement, sequence_no), from_=olympus):
# >>>>>>> ea413ec0e772fca4f8c559bc7be96602c0d2c27a
        output("Replica ", replica_id, ":Received catchup statement :", catchup_statement)
        failure_error = handle_failure_trigger(replica_id, None, sequence_no, failure_scenario_properties,'catch_up')
        output("failure_error :", failure_error)
        if failure_error:
            failure_error_dict = handle_failure_error(failure_error)
            if failure_error_dict['crash'] == True:
                output("Replica ", replica_id, " is crashing due to fault injection.")
                logging.shutdown()
                os._exit(1)
        output("Before: State of dictionary :", dictionary)
        # result = None
        # operation = None
        # sequence_number = None
        results = []
        for order_proof in catchup_statement:
            result = operations.perform_operation(order_proof.operation, dictionary)
            operation = order_proof.operation
            sequence_number = order_proof.sequence_number
            results.append((result, operation, sequence_number))
        else:
            output("No caughtup statements found")

        #latest_result_stmt[client_id] = {}
        ### WORK IN PROGRESS
        for r in results:
            operation = r[1]
            seq_num   = r[2]
            result    = r[0]
            result_statement = messages.ResultStatement('result', result, sign.generate_hash(result.encode('ascii')), operation)
            signed_result_statement = sign.sign_msg(signing_key, pickle.dumps(result_statement))            
            if not client_id in latest_result_stmt:
                latest_result_stmt[client_id] = {}
            latest_result_stmt[client_id][(operation, seq_num)] = signed_result_statement

        # result_statement = messages.ResultStatement('result', result, sign.generate_hash(result.encode('ascii')), operation)
        # signed_result_statement = sign.sign_msg(signing_key, pickle.dumps(result_statement))
        # latest_result_stmt[client_id] = signed_result_statement

        output('State of dictionary :', dictionary)
        hashed_running_state = sign.generate_hash(pickle.dumps(dictionary))
        output("Replica ", replica_id, " sending caughtup statement to olympus")
        send(('CaughtupStatement', hashed_running_state, replica_id, latest_result_stmt[client_id], client_id), to=olympus)


    def receive(msg=('GetRunningState', sequence_no), from_=olympus):
        output("Replica ", replica_id, " received getrunning state request from olympus.")
        failure_error = handle_failure_trigger(replica_id, None, sequence_no,
        failure_scenario_properties,'get_running_state')
        output("failure_error :", failure_error)
        if failure_error:
            failure_error_dict = handle_failure_error(failure_error)
            if failure_error_dict['extra_op'] == True:
                result = operations.perform_operation("put('a','a')", dictionary)
                output("Replica :", replica_id, " Injecting failure extra op.")
        send(('RunningState', dictionary, replica_id), to=olympus)
                

    def receive(msg=('Terminate'), from_=olympus):
        output('Replica', replica_id, 'exiting on message from Olympus')
        kill = True

    def receive(msg=('Hello'), from_=olympus):
        output('Replica', replica_id, 'received hello from Olympus')        
        send(('ReplicaUp', replica_id), to=olympus)

    def start_new_operation(operation, client, client_id, sequence_number):
        #add operation at the next slot
        forward_shuttle = None
        forward_shuttle = order_operation(operation, client, client_id, sequence_number)
        if not forward_shuttle == None:
            output('Replica:', replica_id, 'orderCommand transition')

            #apply operation to running state and add result proof to forward shuttle
            result = operations.perform_operation(operation, dictionary)
            output('State of dictionary at Head:', dictionary)
            output('Result obtained at Head for operation:', operation,'is: ',result)
            result_proof, signed_result_statement = create_result_proof(result, slot_number, operation, sequence_number, client_id)
            forward_shuttle.add_result_proof(result_proof)

            if not client_id in latest_result_stmt:
                latest_result_stmt[client_id] = {}
            latest_result_stmt[client_id][(operation, sequence_number)] = signed_result_statement
            output('Replica Head: Sequence number', sequence_number)
        return forward_shuttle

def main():
    print('Replica main method')
    sys.exit()
